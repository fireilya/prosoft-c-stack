# Техническое задание

_**Общие требования**_. Данное техническое задание формулирует следующие требования к вашему ПО:
1. Модуль, реализующий стек, должен быть выполнен как _статическая библиотека_. Это требование выполняется автоматически
([CMakeLists.txt](https://github.com/czertyaka/prosoft-c-stack/blob/master/CMakeLists.txt)) - весь код из `cstack.c` попадет в библиотеку.
2. Библиотека должна _собираться_, т.е. в ней не должно быть ошибок компиляции и линковки (за исключением ситуации отсутствия на машине
сборки стандартной библиотеки C).
3. Библиотека _не должна иметь зависимостей_ иных, чем стандартная библиотека C.
Не сомневаюсь, что при должном упорстве можно найти готовые реализации стека на С, удовлетворяющие нашим требованиям.
Это не наш случай :smiling_face_with_tear:.
5. Функции библиотеки должны удовлетворять требованиям, описанным ниже.
6. Библиотека должна корректно _освобождать ресурсы памяти_ при должном использовании.
7. Библиотека должна быть _отказоустойчива_ (в разумных пределах) _к входным данным_ функций, т.е. должны быть введены разумные проверки на нулевой указатель, нулевой размер и т.д. Понятно, что проверить валидность переданного указателя (например, что он не указывает в начало адресного пространства) невозможно или очень трудно, но полноценная проверка и не является ответственностью библиотеки.
8. В ходе нормального выполнения и использования кода библиотеки не должны возникать ошибки сегментации, переполнения стека, обращения к
памяти и др.
9. Библиотека не гарантирует: освобождение ресурсов памяти при некорректном использовании функций библиотеки; отсутствие недекларированного
поведения в случае передачи невалидного указателя (за исключением нулевого указателя).

Валидация этих требований будет осуществляется в процессе код-ревью, сборки и юнит-тестирования. Обратите внимание, что последние два
валидатора могут быть выполнены вами в целях экономии времени (в том числе и вашего). Но это лишь предложение по оптимизации процесса
проверки, а не требование. Обратите внимание, что юнит-тесты могут быть модифицированы в случае выявления недостаточности
проверок/несоответствия приведенным выше требованиям. Требования - первичны, а тесты всего лишь их выражают.

_**Особенности нашей реализации стека**_.
1. Библиотека может одновременно обслуживать несколько стеков.
2. Данные, хранимые в стеке, не типизированны.

**_Требования к функциям библиотеки_**.
Одним из аргументов большинства функций библиотеки является _хэндлер_ стека с типом `t_hstack`. Этот тип является псевдонимом типа `int`
и к реализации стека в памяти отношения не имеет. Скорее это абстрактный идентификатор, который нужен, чтобы отличить один стек от другого.
Отмечу, что в C использование _хэндлера_, (_дескриптора_), является стандартной практикой. Примеры:
[hInstance](https://learn.microsoft.com/ru-ru/windows/win32/learnwin32/winmain--the-application-entry-point) в `WinAPI`, возвращаемое
значение функции [open](https://man7.org/linux/man-pages/man2/open.2.html) в `POSIX`. Объявление этого типа находится в заголовочном файле
[cstack.h](https://github.com/czertyaka/prosoft-c-stack/blob/master/cstack.h).

* `hstack_t stack_new(void)`  
**Brief**: Создать новый стек.  
**Returns**: `-1` в случае ошибки выполнения, хэндлер нового стека с неотрицательным значением в случае успеха.

* `void stack_free(const hstack_t stack)`  
**Brief**: Удалить стек.  
**Parameters**: `stack` - хэндлер стека.

* `int stack_valid_handler(const hstack_t stack)`  
**Brief**: Проверить хэндлер.  
**Parameters**: `stack` - хэндлер стека.  
**Returns**: 0 - соответствующий хэндлеру стек существует, 1 - нет.

* `unsigned int stack_size(const hstack_t stack)`  
**Brief**: Получить количество элементов в стеке.  
**Parameters**: `stack` - хэндлер стека.  
**Returns**: количество элементов в стеке.

* `void stack_push(const hstack_t stack, const void* data_in, const unsigned int size)`  
**Brief**: Добавить элемент данных из буфера в стек.  
**Parameters**: `stack` - хэндлер стека; `data_in` - указатель на буфер с данными; `size` - размер буфера с данными.

* `unsigned int stack_pop(const hstack_t stack, void* data_out, const unsigned int size)`  
**Brief**: Извлечь элемент из стека и записать данные этого элемента в буфер.  
**Parameters**: `stack` - хэндлер стека; `data_out` - указатель на буфер для записи данных; `size` - размер буфера.  
**Returns**: размер записанных данных в байтах.

**_Подсказки по реализации_**. Прежде чем давать задание вам, я самостоятельно реализовал стек, чтобы было проще декомпозировать задачу и
подумать, в каких местах стоит дать подсказки. Эта часть необязательна к прочтению, ограничений на реализацию я не ставлю (кроме приведенных
в требованиях).

На мой взгляд, две главные проблемы, которые вам предстоит решить - как хранить сами данные в стеке и как устанавливать соответствие между
хэндлером и стеком.

Первая проблема решалась бы тривиально, если бы мы релизовывали стек, хранящий типизированные данные.
Тогда мы бы на этапе компиляции знали размер одного элемента стека.
Например, если бы мы хранили `int`, размер элемента стека в простой реализации был бы равен `sizeof(int)`.
В этом случае можно было бы вовсе обойтись без динамической памяти.
Для случая неизвестного на этапе компиляции размера я выбрал вот такое решение:
```c
struct node
{
    const struct node* prev;
    unsigned int size;
    char data[0];
};
```
Такой подход напоминает другую структуру данных [односвязный список](https://prog-cpp.ru/data-ols/).
Из общего у них наличие указателя на предыдущий элемент.
При добавлении нового элемента в стек удобно в рантайме посчитать количество данных элемента стека
(размер указателя на предыдущий элемент `prev` + размер поля `size` + размер самих данных), аллоцировать
эти данные и заполнить их.
Это не единственно верный вариант, возможны альтернативы.

Вторую проблему я решил следующим образом: завел глобальный динамический массив указателей на верхушки стека так,
чтобы дескриптор стека являлся одновременно и индексом в этом массиве.
Добавил несколько оптимизаций, но общая идея такая.
```c
struct stack_entry
{
    int reserved;
    stack_t stack;
};

typedef struct stack_entry stack_entry_t;

struct stack_entries_table
{
    unsigned int size;
    stack_entry_t* entries;
};

struct stack_entries_table g_table = {0u, NULL};
```
**_Пошаговая инструкция_**

1. Если вы незнакомы с системой контроля версий Git, познакомьтесь с её основами.
    Во всех дальнейших домашних работах вам эти знания всё равно понадобятся.
    Для начала достаточно изучить самые базовые команды (``add``, ``commit``, ``pull``, ``push`` и несколько других).
    Начать знакомство рекомендую [здесь](https://git-scm.com/book/ru/v2).
3. Заведите профиль на <https://github.com/>.
4. Сделайте форк репозитория. После этого в вашем аккаунте среди ваших репозиториев появится копия данного репозитория с веткой `master`.
    ![Screenshot from 2023-11-19 21-10-28](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/c0c24f41-64cb-4c47-a883-63c150712a84)
    ![Screenshot from 2023-11-19 21-14-07](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/517553c2-a696-4644-ac25-c6ba39f6607c)
    ![image](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/b04466b9-858e-44ee-a08a-4d1f086bd0c3)
5. Склонируйте репозиторий на ваш компьютер. Создайте ветку в вашем репозитории с названием, отличным от `master`.
В командной строке Linux или GitBash на Windows это можно сделать следующим образом:
    ![Screenshot from 2023-11-19 21-19-17](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/968f62e9-7b54-4a98-b937-26a92edec962)
    ```sh
    git clone <ссылка из буфера обмена>
    cd prosoft-c-stack/
    git checkout -b development
    git push --set-upstream origin development
    ```
4. Выполните вашу первую реализацию задания, закоммитьте и запушьте изменения.
    ```sh
    git add cstack.c
    git commit -m "my first commit"
    git push
    ```
5. Создайте пулл-реквест в вашем репозитории из вашей ветки в ветку `master`.
    Обратите внимание, что в качестве base ветки нужно выбрать ветку из *вашего* репозитория.
    ![Screenshot from 2023-11-19 21-57-23](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/0b105305-4eae-49b0-85ec-b42f77324221)
    ![image](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/aabe4444-66d7-4150-b03d-63c04ae9aeef)
    ![Screenshot from 2023-11-19 21-59-32](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/ee2897f5-86b1-41ed-b336-5fb324324288)
    ![Screenshot from 2023-11-19 22-03-28](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/71830c4b-b854-4d5d-8235-89ef9e86287d)
6. В названии пулл-реквеста укажите фамилию и имя.
    ![Screenshot from 2023-11-19 22-08-56](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/4ecaf09b-6329-4d49-95fb-f093ad72220b)
    ![image](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/9b79dce5-1d9f-4e70-8a2d-f9a5418821dc)
7. Добавьте меня (czertyaka) в качестве коллаборатора в ваш проект.
    ![Screenshot from 2023-11-19 22-12-27](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/70d43d5e-0a5f-42f3-b1c8-78d58de74874)
    ![Screenshot from 2023-11-19 22-13-35](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/28ec2e77-30a4-4467-880e-b39c4f67bf4c)
    ![Screenshot from 2023-11-19 22-14-24](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/8fd2719d-be9b-4395-aaa3-ea30f07c04d3)
    ![image](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/671088b3-af2b-4872-9c0f-8ff82253a4f0)
8. После этого я появлюсь в списке коллабораторов в статусе Pending Invite.
    На мою почту придет письмо, в котором меня попросят присоединиться к вашему проекту.
    ![Screenshot from 2023-11-19 22-19-13](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/1938f69e-a51c-4a3a-8a60-bfc19a82701b)
    После моего присоединения:
    ![Screenshot from 2023-11-19 22-21-10](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/5b826543-5666-417d-a579-d1167042d224)
9. Добавьте меня в качестве рецензента в ваш пулл-реквест.
    ![Screenshot from 2023-11-19 22-22-30](https://github.com/czertyaka/prosoft-c-stack/assets/69390349/bb2da6ec-aff8-4ef4-b39f-354bac1faa00)
10. Дальше начинается процесс ревью. Если у меня есть замечания, я их делаю, вы правите код.

Вот [тут](https://git-scm.com/book/ru/v2/GitHub-%D0%92%D0%BD%D0%B5%D1%81%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D0%BA%D0%BB%D0%B0%D0%B4%D0%B0-%D0%B2-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B) подробнее про совместную работу над проектами, форки, пулл-реквесты и т.д.
